using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Diagnostics;
using System.Threading;

namespace _10
{
    //Если программа вызывается без аргументов, рабочий поток выполняется по умолчанию 
    //как основной поток и ожидает на ReadLine, пока пользователь не нажмет Enter. 
    //Тем временем главный поток завершается, но приложение продолжает исполняться, 
    //так как рабочий поток еще жив.

    //Если же программу запустить с аргументами командной строки, рабочий поток получит 
    //статус фонового и программа завершится практически сразу после завершения главного
    //потока, с уничтожением потока, ожидающего ввода пользователя с помощью метода ReadLine.
    class Program
    {
        static void Main(string[] args)
        {
            Thread worker = new Thread(delegate() { Console.ReadLine(); });

            if (args.Length > 0)
                worker.IsBackground = true;

            worker.Start();
            //Когда фоновый поток завершается таким способом, все блоки finally внутри потока
            //игнорируются. Поскольку невыполнение кода в finally обычно нежелательно, 
            //будет правильно ожидать завершения всех фоновых потоков перед выходом из программы, 
            //назначив нужный таймаут (при помощи Thread.Join). 
            //Если по каким-то причинам рабочий поток не завершается за выделенное время, 
            //можно попытаться аварийно завершить его (Thread.Abort), а если и это не получится,
            //позволить умереть ему вместе с процессом (также не помешает записать информацию 
            //о проблеме в лог).
            //worker.Join(6000);
            //worker.Priority = ThreadPriority.Highest;
            //Установка приоритета потока на максимум еще не означает работу в реальном 
            //времени (real-time), так как существуют еще приоритет процесса приложения. 
            //Чтобы работать в реальном времени, нужно использовать класс Process из 
            //пространства имен System.Diagnostics для поднятия приоритета процесса (!?):
            //Process.GetCurrentProcess().PriorityClass = ProcessPriorityClass.High;
            //От ProcessPriorityClass.High один шаг до наивысшего приоритета процесса – Realtime.
            //Устанавливая приоритет процесса в Realtime, вы говорите операционной системе, 
            //что хотите, чтобы ваш процесс никогда не вытеснялся. Если ваша программа случайно 
            //попадет в бесконечный цикл, операционная система может быть полностью заблокирована. 
            //Спасти вас в этом случае сможет только кнопка выключения питания. 
            //По этой причине ProcessPriorityClass.High считается максимальным приоритетом процесса,
            //пригодным к употреблению.
        }
        
    }
}
