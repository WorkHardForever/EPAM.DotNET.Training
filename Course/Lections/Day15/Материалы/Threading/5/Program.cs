using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;

namespace _5
{
    class ThreadSafe
    {
        static bool done;
        static object locker = new object();//блокировка

        static void Main()
        {
            //new Thread(Go).Start();
            //Go();
            //Временная приостановка (блокирование) – основной способ синхронизации действий потоков.
            //Ожидание эксклюзивной блокировки – это одна из причин, по которым поток может блокироваться. 
            //Другая причина – если поток приостанавливается (Sleep) на заданный промежуток времени:
            Thread.Sleep(TimeSpan.FromSeconds(30)); // Блокировка на 30 секунд
            //также поток может ожидать завершения другого потока, вызывая его метод Join:
            //Thread t = new Thread(Go);     // Go – статический метод
            //t.Start();
            //t.Join();                       // Ожидаем завершения потока
            Console.ReadKey();
        }

        static void Go()
        {
            //Решение состоит в получении эксклюзивной блокировки на время чтения и записи разделяемых полей.
            //C# обеспечивает это при помощи оператора lock
            //Когда два потока одновременно борются за блокировку (в нашем случае объекта locker),
            //один поток переходит к ожиданию (блокируется), пока блокировка не освобождается. 
            //В данном случае это гарантирует, что только один поток может одновременно исполнять
            //критическую секцию кода, и "Done" будет напечатано только один раз. 
            //Код, защищенный таким образом от неопределённости в плане многопоточного исполнения, называется потокобезопасным.
            lock (locker)//Будучи блокированным, поток не потребляет ресурсов CPU!
            {
                if (!done)
                {
                    Console.WriteLine("Done");
                    done = true;
                }
            }
        }
    }
}
